并发：指两个或多个事件在同一个时间段内发生
并行：指两个或多个事件在同一时刻发生（同时发生）

进程：点击应用程序，进入到内存中，占用一些内存执行。进入到内存的程序就叫进程
线程：线程是进程的一个执行单位，一个进程最少有一个线程，可以有多个线程，线程越多越好，效率高且互不干扰
    线程调度
        分时调度
            所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间
        抢占式调度
            优先让优先级搞得线程使用CPU，如果线程的优先级相同，那么会随机选择一个线程（线程随机性）使用CPU
    主线程：执行主（main）方法的线程
        也是单线程程序
    多线程
        创建多线程的两种方式
            继承Thread类，子类需重写run()方法来设置线程任务
                使用
                    MyThread myThread = new MyThread(); 创建一个线程对象 new一个线程对象时，就已经创建了一个线程
                    myThread.start(); 执行start方法
                Thread
                    构造方法
                        Thread()
                        Thread(String name) name参数为线程的名称
                        Thread(Runable target) 分配新的 Thread 对象。target为 Runable接口实现类的对象
                        Thread(Runable target, String name) 分配新的 Thread 对象。target为 Runable接口实现类的对象,name为线程名称
                    常用方法
                        String getName() 返回该线程的名称
                        void setName() 设置线程名称
                        static Thread currentThread() (获取线程对象)返回当前正在执行的线程对象的引用
                        static void sleep(Long millis) 使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）
                            毫秒数结束之后，线程继续执行
            实现Runable接口（优先考虑），必须重写run()方法来设置线程任务
                使用
                    实现类 变量名 = new 实现类(); 先实例化一个实现类对象
                    new Thread(变量名).start();    再把这个实现类对象传给Thread来new一个对象来调用start()方法
        Thread和Runable的区别
            实现Runable接口创建多线程程序的好处
                避免了单继承的局限性
                    一个类只能继承一个类，类继承了Thread类就不能继承其他的类了
                    实现Runable接口，还可以继承其他的类，实现其他的接口
                增强了程序的扩展性，降低了程序的耦合性（解耦）
                    实现Runable接口的方法，把设置线程任务和开启新线程进行了分类（解耦）
                    实现类中，重写了run方法：用来设置线程任务
                    创建Thread类对象，调用start方法：用来开启新线程
        匿名内部类方式实现线程的创建
            直接在方法里面new Thread/Runable来创建线程对象
    线程安全问题
        卖票案例
            出现了重复的票
            出现了不存在的票
    线程同步机制（解决线程安全问题）
        三种解决方案
            同步代码块
                synchronized(锁对象){
                    可能会出现线程安全问题的代码（访问了共享数据的代码）
                }
                同步代码块会把方法内部的代码锁住，只让抢到锁对象的线程执行，
                利端：同步保证了只能有一个线程在同步中执行共享数据保证了安全
                弊端：程序频繁的判断锁，获取锁，释放锁，程序的效率会降低
                注意
                    通过代码块中的锁对象，可以使用任意的对象
                    但是必须保证多个线程使用的锁对象是同一个
                    锁对象的作用：把同步代码块锁住，只让一个线程在同步代码块中进行
            同步方法
                修饰符 synchronized 返回值类型 方法名(参数列表){
                    可能会出现线程安全问题的代码(访问了共享数据的代码)
                }
                同步方法也会把方法内部的代码锁住，只让一个线程执行，同步方法的锁对象就是实现类的对象,也就是this
                静态的同步方法
                    锁对象不能是this,this是创建对象之后产生的，静态方法优先于对象，所以静态方法的锁对象是本类的class属性-->class对象本身（RunableImpl.class）
            Lock锁接口
                Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作
                Lock接口中的方法：
                    void lock() 获取锁
                    void unlock() 释放锁
                实现类
                    ReentrantLock implements Lock接口
                使用步骤
                    在成员位置创建一个ReentrantLock对象 Lock lock = new ReentrantLock();
                    在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁
                    在可以会出现安全问题的代码后调用Lock接口中的方法unlock释放锁
    线程状态
        NEW （新建状态）至今尚未启动的线程处于这个状态
        RUNNABLE （运行状态）正在 Java 虚拟机中执行的线程处于这种状态
        BLOCKED （阻塞状态）受阻塞并等待某个监视器锁的线程处于这种状态
        WAITING （无限等待状态）无限期的等待另一个线程来执行某一特定操作的线程处于这种状态
        TIMED_WAITING （休眠状态）等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态
        TERMINATED （死亡状态）已退出的线程处于这种状态
    等待唤醒机制（线程之间的通信）
        创建一个顾客线程（消费者）：告知老板要的包子的种类和数量，调用wait()方法，放弃cpu的执行，进入到WAITING状态（无限等待）
        创建一个老板线程（生产者）：花了5秒做包子，做好包子之后，调用notify()方法，唤醒顾客吃包子
        注意
            顾客和老板线程必须使用同步代码块包裹起来，保证等待和唤醒只能有一个在执行
            同步使用的锁对象必须保证唯一
            只有锁对象才能调用wait()和notify方法
        Object类中的方法
            void wait() 在其他线程调用此对象的notify()方法或notifyAll()方法前，导致当前线程等待
            void wait(long m) wait方法如果在毫秒值结束之后，还没有被notify唤醒，就会自动醒来，线程睡醒进入到Runnable/Blocked状态
            void notify() 唤醒在此对象监视器上等待的单个线程，继续执行wait方法之后的代码
            void notifyAll() 唤醒所有等待的线程
    线程池（容器）
        其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，
            无需反复创建线程而消耗过多资源
        合理利用线程池的三个好处
            降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以别重复利用，可执行多个任务
            提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行
            提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线程的数目，防止因为消耗过多的内
                存，而把服务器累趴下（每个线程需要大约1MB内存，线程开的越多，消耗内存也就越大，最后死机）
        Executors 线程池的工厂类，用来生成线程池
            static ExecutorService newFixedThreadPool(int nThreads) 创建一个可重用的线程池
            参数
                int nThreads 创建线程池中包含的线程数量
            返回值
                ExecutorService接口，返回的是ExecutorService接口的实现类对象，可以用ExecutorService接口接受（面向接口编程）
        ExecutorService 线程池接口，用来从线程池中获取线程，调用start方法，执行线程任务
            submit(Runnable task) 提交一个 Runnable 任务用于执行
            void shutdown() 关闭/销毁线程池的方法
        线程池的使用步骤
            使用线程池的工厂类Executors里面提供的静态方法newFixedThreadPool生产一个执行线程数量的线程池
            创建一个类，实现Runnable接口，重写run方法，设置线程任务
            调用ExecutorService中的方法submit，传递线程任务（实现类），开启线程，执行run方法
            调用ExecutorService中的方法shutdown销毁线程池（不建议执行）
Lambda表达式（简化接口匿名内部类的写法）
    使用前提
        使用Lambda必须具有接口，且要求接口有且仅有一个抽象方法
    由三部分组成
        一些参数
        一个箭头
        一段代码
    格式：(参数列表) -> {一些重写方法的代码}
        ():接口中抽象方法的参数列表，没有参数，就空着；有参数就写参数，多个参数用逗号隔开
        ->:传递的意思，把参数传递给方法体{}
        {}:重写接口的抽象方法的方法体




