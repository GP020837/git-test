继承
    不同作用域的取值
        局部变量            直接写成员变量名称
        本来的成员变量      this.成员变量名
        父类的成员变量      super.成员变量名

    重写（Override）
        在继承关系当中，方法的名称一样，参数列表也一样
        子类方法的返回值必须小于等于父类方法的返回值范围 例Object、String
        子类方法的权限必须大于等于父类的权限修饰符
    重载（Overload）
        在同一个类中，方法的名称一样，参数类别不一样

    父子类构造方法的访问特点
        子类构造方法当中有一个默认隐含的“super()”调用，
            所以一定是先调用的父类构造，后执行的子类构造
        子类构造可以通过super关键字来调用父类重载构造
        super的父类构造调用，必须是子类构造方法的第一个语句，
            不能一个子类构造调用多次super构造
        总结：子类必须调用父类构造方法，不写则隐含super()，写了则使用指定的super调用

    super
         三种用法
            在子类的构造方法中，访问父类的构造方法
            在子类的成员方法中，访问父类的成员变量
            在子类的成员方法中，访问父类的成员方法
    this
        三种用法
            在本类的构造方法中，访问本类的另一个构造方法
            在本类的成员方法中，访问本类成员变量
            在本类的成员方法中，访问本类另一个成员变量

    三个特点
        单继承（一个类只能继承一个父类）
        多级继承（父类可以有一个父类）
        父类可以有多个子类

抽象 abstract
    抽象类
        抽象方法（只能在抽象类中才有抽象方法）
    注意事项
        抽象类不能直接创建new抽象类对象
        抽象类可以有构造方法，是供子类创建对象时，初始化父类成员使用的（继承）
        抽象类不一定要有抽象方法，但有抽象方法的类一定是抽象类
        子类必须覆盖重写抽象父类当中所有的抽象方法

    写一个发红包的案例
        思路：
            人
                群主
                    发红包
                        可自定义红包金额，和红包数量
                        从原有金额上把红包的金额扣除
                        包装成数组返回

                群员
                    点红包
                        获取数组，根据红包数量遍历
                        在红包总金额以内中随机生成两个小数点的红包
                        在原有金额上加上随机红包金额

接口
    Java 7 包含内容
        常量
            必须赋值
            一旦赋值不能修改
        抽象方法
    Java 8 包含内容
        默认方法
        静态方法
    Java 9 包含内容
        私有方法

    注意事项
        接口是没有静态代码块或者构造方法的
        一个类的直接父类是唯一的，但是一个类可以实现多个接口
        如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可
        如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类
        如果实现类所实现的多个接口当中吗，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写
        一个类如果父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法
        接口与接口可以多继承
            多个父接口当中的抽象方法如果重复，没关系
            多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写（带着default关键字）

多态
    父类引用指向子类对象（这就是多态的体现）
        父类名称 对象名 = new 子类名称()
        接口名称 对象名 = new 实现类名称()

    成员变量的使用特点
        直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找
        间接通过成员方法访问成员变量：看该成员方法属于谁，优先用谁，没有则向上找

    成员方法的使用特点
        看new的是谁，就优先用谁，没有则向上找

    多态的好处
        无论右边new的时候换成哪个子类对象，等号左边调用方法都不会变化

    对象的向上转型（就是多态写法【父类引用指向子类对象】）
        格式：父类名称 对象名 = new 子类名称();
        含义：右侧创建了一个子类对象，把它当做父类来看待使用  //创建了一只猫，当做动物看待
        注意事项：向上转型一定是安全的，但是调用子类特有的方法会报错
    对象的向下转型
        格式：子类名称 对象名 = （子类名称）父类对象
        含义：将父类对象，【还原】成为本来的子类对象
            Animal animal = new Cat();//本来是猫，向上转型成为动物
            Cat cat = (Cat)animal;//本来是猫，已经被当做动物了，还原回来成为本来的猫

instanceof
    格式
        对象 instanceof 类名称 （这将会得到一个boolean值结果，也就是前面的对象能不能当做后面类型的实例）

接口多态的综合案例
    笔记本电脑
        笔记本电脑（laptop）通常具备使用USB设备的功能。在生产时，笔记本都预留了可以插入USB设备的USB接口，
        但是具体是什么USB设备，笔记本厂商并不关心，只要符合USB规格的设备都可以。

        定义USB接口，具备最基本的开启功能和关闭功能。鼠标和键盘想要能在电脑上使用，那么鼠标和键盘也必须遵守
        USB规范，实现USB接口，否则鼠标和键盘的生产出来也无法使用。

    案例分析
        USB接口，包含打开设备功能，关闭设备功能
        笔记本类，包含开机功能，关机功能，使用USB设备功能
        鼠标类，实现USB接口，并具备点击的方法
        键盘类，实现USB接口，并具备敲击的方法

final
    四种用法
        修饰类：当前这个类不能有任何的子类
        修饰方法：这个方法是最终方法，不能被覆盖重写（与 abstract 关键字冲突，不能同时使用）
        修饰局部变量：这个局部变量运行时赋值一次后不能被修改
            基本类型：数据值不变
            引用类型：地址值不变
        修饰成员变量
            由于成员变量都有默认值，所有用了final之后必须手动赋值，不会再给默认值了
            对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值，二者选其一
            必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值


权限修饰符
                    public > protected > (default) > private
    同一个类        yes        yes         yes         yes
    同一个包        yes        yes         yes         no
    不同包子类      yes        yes         no          no
    不同包非子类    yes        no          no          no

内部类
    成员内部类
        间接使用方式：在外部类的方法当中，使用内部类，然后main调用外部类的方法
        直接使用方式：外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称()
    局部内部类（包含匿名内部类）
        定义：在成员方法里面的类
        使用方式：直接调用外部类的方法
        如果局部内部类希望访问所在方法的局部变量，那么这个局部变量必须是final(不能修改的)
            原因：new出来的对象在堆内存中，而局部变量时跟在方法走的，在栈内存中
            方法运行结束后，立刻出栈，局部变量就会消失。但是new出来的局部内部类直到垃圾回收才消失，
            所以为了避免这种问题，局部内部类调用局部变量时，这个局部变量要final(不能修改)
    匿名内部类
        定义格式：
            接口名称 对象名 = new 接口名称(){
                //覆盖重写所有抽象方法
            }
        注意事项
            匿名内部类，在【创建对象】的时候，只能使用唯一一次
                如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了
            匿名对象，在【调用方法】的时候，只能调用唯一一次，
                如果希望同一个对象，调用多次方法，那么必须给对象七个名字
            匿名内部类是省略了【实现类/子类名称】，但是匿名对象时省略了【对象名称】
                强调：匿名内部类和匿名对象不是一回事！
